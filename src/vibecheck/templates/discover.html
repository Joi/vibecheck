{% extends "base.html" %}

{% block title %}Discover{% endblock %}

{% block extra_styles %}
<style>
    /* === DISCOVER TOKENS (harmonized with global theme) === */
    .discover-container {
        --card-bg: var(--bg-secondary);
        --card-bg-deep: var(--bg);
        --card-border: var(--border);
        --card-text: var(--text);
        --card-text-secondary: var(--text-secondary);
        --card-text-muted: var(--text-muted);
        --card-accent: var(--accent);
        --card-accent-dim: var(--accent-dim);
        --pass-color: #f87171;
        --like-color: #4ade80;
        --save-color: #60a5fa;
        --save-gold: #fbbf24;
        --article-accent: #f0abfc;

        max-width: 420px;
        margin: 0 auto;
        padding: 0.75rem;
        padding-bottom: env(safe-area-inset-bottom, 0.75rem);
        min-height: 90vh;
        min-height: 90dvh;
        display: flex;
        flex-direction: column;
        align-items: center;
    }

    .discover-container h1 {
        margin-bottom: 0.15rem;
        font-size: 1.5rem;
    }

    .subtitle {
        margin-bottom: 0.5rem;
        color: var(--card-text-muted);
        font-size: 0.85rem;
    }

    /* === CARD STACK === */
    .card-stack {
        position: relative;
        width: 100%;
        height: clamp(380px, 58vh, 520px);
        height: clamp(380px, 58dvh, 520px);
        margin: 0.5rem 0;
    }

    /* === THE CARD === */
    .swipe-card {
        position: absolute;
        width: 100%;
        height: 100%;
        background: linear-gradient(165deg, var(--card-bg) 0%, var(--card-bg-deep) 100%);
        border: 1.5px solid var(--card-border);
        border-radius: 20px;
        display: flex;
        flex-direction: column;
        box-shadow: 0 4px 24px rgba(0,0,0,0.25);
        overflow: hidden;
        /* Spring-like snap-back: cubic-bezier overshoots then settles */
        transition: transform 0.5s cubic-bezier(0.34, 1.56, 0.64, 1),
                    opacity 0.4s ease-out,
                    box-shadow 0.2s ease,
                    filter 0.4s ease;
        will-change: transform, opacity;
    }

    /* Card entrance animation */
    .swipe-card.entering {
        opacity: 0;
        transform: scale(0.92) translateY(12px);
    }

    .swipe-card.dragging {
        transition: none;
        box-shadow: 0 12px 48px rgba(0,0,0,0.45);
    }

    /* Exit animations - speed set dynamically by JS */
    .swipe-card.swiped-left {
        transform: translateX(-130%) rotate(-18deg);
        opacity: 0;
    }

    .swipe-card.swiped-right {
        transform: translateX(130%) rotate(18deg);
        opacity: 0;
    }

    .swipe-card.swiped-up {
        transform: translateY(-140%) scale(0.9);
        opacity: 0;
    }

    /* Drag state visual feedback - colored border + directional glow */
    .swipe-card.drag-left {
        border-color: var(--pass-color);
        box-shadow: 0 8px 40px rgba(0,0,0,0.4), -4px 0 24px rgba(248, 113, 113, 0.15);
    }
    .swipe-card.drag-right {
        border-color: var(--like-color);
        box-shadow: 0 8px 40px rgba(0,0,0,0.4), 4px 0 24px rgba(74, 222, 128, 0.15);
    }
    .swipe-card.drag-up {
        border-color: var(--save-color);
        box-shadow: 0 8px 40px rgba(0,0,0,0.4), 0 -4px 24px rgba(96, 165, 250, 0.15);
    }

    /* === SCROLLABLE CONTENT ZONE === */
    .card-content {
        flex: 1;
        padding: 1.5rem 1.5rem 1rem;
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
        touch-action: pan-y; /* Allow vertical scroll here */
    }

    .card-type-badge {
        display: inline-block;
        padding: 0.2rem 0.6rem;
        background: var(--card-accent);
        color: var(--bg);
        border-radius: 6px;
        font-size: 0.6rem;
        text-transform: uppercase;
        font-weight: 700;
        letter-spacing: 0.8px;
        margin-bottom: 0.85rem;
    }

    .card-type-badge.article {
        background: var(--article-accent);
    }

    .card-title {
        font-size: 1.3rem;
        margin: 0 0 0.6rem 0;
        line-height: 1.3;
        font-weight: 700;
        color: var(--card-text);
    }

    .card-title a {
        color: inherit;
        text-decoration: none;
    }

    .card-title a:hover {
        color: var(--card-accent);
    }

    .card-description {
        color: var(--card-text-secondary);
        font-size: 0.9rem;
        line-height: 1.6;
    }

    .card-tags {
        display: flex;
        flex-wrap: wrap;
        gap: 0.35rem;
        margin-top: 0.85rem;
    }

    .card-tags .tag {
        background: rgba(168, 85, 247, 0.1);
        border: 1px solid rgba(168, 85, 247, 0.18);
        color: var(--card-accent);
        padding: 0.2rem 0.5rem;
        border-radius: 6px;
        font-size: 0.7rem;
        font-weight: 500;
    }

    .card-meta {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
        color: var(--card-text-muted);
        font-size: 0.75rem;
        margin-top: 0.85rem;
    }

    /* === SWIPE HANDLE ZONE === */
    .swipe-handle {
        height: 64px;
        min-height: 64px;
        touch-action: none; /* Capture ALL touch here for swiping */
        background: linear-gradient(to bottom, transparent, rgba(0,0,0,0.12));
        position: relative;
        cursor: grab;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        padding: 0.4rem 0.75rem;
        gap: 0.4rem;
        user-select: none;
        -webkit-user-select: none;
    }

    .swipe-handle:active {
        cursor: grabbing;
    }

    /* Subtle grab-bar pill indicator */
    .grab-indicator {
        width: 36px;
        height: 4px;
        background: var(--card-text-muted);
        border-radius: 2px;
        opacity: 0.35;
        transition: opacity 0.2s, width 0.2s;
    }

    .swipe-card.dragging .grab-indicator {
        opacity: 0.6;
        width: 48px;
    }

    /* Screen-reader only instruction */
    .handle-instruction {
        position: absolute;
        width: 1px;
        height: 1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
    }

    /* Direction hints - hidden until drag starts */
    .direction-hints {
        display: flex;
        flex-direction: row;
        justify-content: space-between;
        align-items: center;
        width: 100%;
        max-width: 260px;
        opacity: 0;
        transform: translateY(4px);
        transition: opacity 0.2s ease, transform 0.2s ease;
        pointer-events: none;
    }

    .swipe-card.dragging .direction-hints {
        opacity: 1;
        transform: translateY(0);
    }

    .direction-hint {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 0.1rem;
        opacity: 0.35;
        transition: opacity 0.15s, transform 0.15s;
        padding: 0.1rem 0.5rem;
    }

    .direction-hint.active {
        opacity: 1;
        transform: scale(1.15);
    }

    .direction-hint .icon {
        font-size: 1rem;
        line-height: 1;
    }

    .direction-hint .label {
        font-size: 0.5rem;
        text-transform: uppercase;
        font-weight: 700;
        letter-spacing: 0.5px;
        white-space: nowrap;
    }

    .direction-hint.pass { color: var(--pass-color); }
    .direction-hint.save { color: var(--save-gold); }
    .direction-hint.like { color: var(--like-color); }

    /* === OVERLAYS === */
    .swipe-overlay {
        position: absolute;
        inset: 0;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.1s;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 3.5rem;
        font-weight: bold;
        border-radius: 20px;
        z-index: 10;
    }

    .swipe-overlay.pass {
        background: linear-gradient(to left, transparent 40%, rgba(248, 113, 113, 0.18));
        color: var(--pass-color);
    }

    .swipe-overlay.like {
        background: linear-gradient(to right, transparent 40%, rgba(74, 222, 128, 0.18));
        color: var(--like-color);
    }

    .swipe-overlay.save {
        background: linear-gradient(to top, transparent 40%, rgba(96, 165, 250, 0.18));
        color: var(--save-color);
    }

    /* === ACTION BUTTONS === */
    .action-buttons {
        display: flex;
        justify-content: center;
        gap: 1.25rem;
        margin-top: 0.75rem;
    }

    .action-btn {
        width: 56px;
        height: 56px;
        border-radius: 50%;
        border: 2px solid;
        background: var(--bg);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.35rem;
        transition: transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1),
                    background 0.15s,
                    box-shadow 0.2s;
    }

    .action-btn:hover {
        transform: scale(1.1);
    }

    .action-btn:active {
        transform: scale(0.88);
    }

    .action-btn.nope {
        border-color: var(--pass-color);
        color: var(--pass-color);
    }
    .action-btn.nope:hover {
        background: rgba(248, 113, 113, 0.1);
        box-shadow: 0 0 20px rgba(248, 113, 113, 0.2);
    }

    .action-btn.bookmark {
        border-color: var(--save-color);
        color: var(--save-color);
    }
    .action-btn.bookmark:hover {
        background: rgba(96, 165, 250, 0.1);
        box-shadow: 0 0 20px rgba(96, 165, 250, 0.2);
    }

    .action-btn.like {
        border-color: var(--like-color);
        color: var(--like-color);
    }
    .action-btn.like:hover {
        background: rgba(74, 222, 128, 0.1);
        box-shadow: 0 0 20px rgba(74, 222, 128, 0.2);
    }

    /* === UNDO BUTTON === */
    .undo-btn {
        width: 44px;
        height: 44px;
        font-size: 1.25rem;
        background: rgba(255,255,255,0.05);
        border: 1px solid var(--border, rgba(255,255,255,0.1));
        border-radius: 50%;
        color: var(--text-secondary, #999);
        cursor: pointer;
        transition: opacity 0.2s, background-color 0.2s;
    }
    .undo-btn:disabled {
        opacity: 0.3;
        cursor: not-allowed;
    }
    .undo-btn:not(:disabled):hover {
        background: rgba(255,255,255,0.1);
        color: var(--text, #fff);
    }

    /* === HEADER CONTROLS === */
    .controls-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        width: 100%;
        margin-bottom: 0.5rem;
    }

    /* Segmented control style mode toggle */
    .mode-toggle {
        display: flex;
        gap: 2px;
        background: var(--bg-secondary);
        border: 1px solid var(--border);
        border-radius: 10px;
        padding: 3px;
    }

    .mode-btn {
        padding: 0.4rem 0.7rem;
        border: none;
        background: transparent;
        color: var(--text-muted);
        border-radius: 7px;
        cursor: pointer;
        font-size: 0.75rem;
        font-weight: 500;
        font-family: inherit;
        transition: all 0.2s;
    }

    .mode-btn:hover {
        color: var(--text-secondary);
    }

    .mode-btn.active {
        background: var(--accent);
        color: white;
        font-weight: 600;
    }

    .score-display {
        display: flex;
        gap: 0.85rem;
    }

    .score-item {
        text-align: center;
    }

    .score-value {
        font-size: 1.1rem;
        font-weight: 700;
        font-variant-numeric: tabular-nums;
    }

    .score-value.liked { color: var(--like-color); }
    .score-value.saved { color: var(--save-color); }
    .score-value.passed { color: var(--pass-color); }

    .score-label {
        font-size: 0.55rem;
        color: var(--text-muted);
        text-transform: uppercase;
        letter-spacing: 0.5px;
    }

    .card-counter {
        font-size: 0.75rem;
        color: var(--text-muted);
        margin-bottom: 0.25rem;
        font-variant-numeric: tabular-nums;
    }

    /* === EMPTY STATE === */
    .empty-state {
        text-align: center;
        padding: 4rem 1.5rem;
    }

    .empty-icon {
        font-size: 3rem;
        margin-bottom: 1rem;
        display: block;
    }

    .empty-state h3 {
        color: var(--text);
        font-size: 1.25rem;
        margin-bottom: 0.5rem;
    }

    .empty-state p {
        color: var(--text-muted);
        margin-bottom: 1.5rem;
        line-height: 1.5;
    }

    .empty-state .back-link {
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
        padding: 0.6rem 1.25rem;
        background: var(--accent);
        color: white;
        border-radius: 8px;
        font-weight: 500;
        font-size: 0.9rem;
        transition: background 0.2s;
    }

    .empty-state .back-link:hover {
        background: var(--accent-dim);
        color: white;
    }

    /* === RESPONSIVE === */
    @media (max-width: 480px) {
        .discover-container {
            padding: 0.5rem;
        }
        .card-stack {
            height: clamp(320px, 52dvh, 460px);
        }
        .card-content {
            padding: 1.25rem 1.25rem 0.75rem;
        }
        .card-title {
            font-size: 1.15rem;
        }
        .action-btn {
            width: 52px;
            height: 52px;
        }
        .mode-btn {
            padding: 0.35rem 0.55rem;
            font-size: 0.7rem;
        }
    }

    @media (min-width: 768px) {
        .card-stack {
            height: clamp(440px, 55vh, 560px);
        }
        .action-btn {
            width: 60px;
            height: 60px;
            font-size: 1.45rem;
        }
    }
</style>
{% endblock %}

{% block content %}
<div class="discover-container">
    <h1>Discover</h1>
    <p class="subtitle">Swipe to rate tools & articles</p>

    <div class="controls-row">
        <div class="mode-toggle">
            <button class="mode-btn {% if mode == 'tools' %}active{% endif %}" onclick="setMode('tools')">Tools</button>
            <button class="mode-btn {% if mode == 'articles' %}active{% endif %}" onclick="setMode('articles')">Articles</button>
            <button class="mode-btn {% if mode == 'mixed' %}active{% endif %}" onclick="setMode('mixed')">Mixed</button>
        </div>

        <div class="score-display">
            <div class="score-item">
                <div class="score-value liked" id="liked-count">0</div>
                <div class="score-label">Like</div>
            </div>
            <div class="score-item">
                <div class="score-value saved" id="bookmarked-count">0</div>
                <div class="score-label">Save</div>
            </div>
            <div class="score-item">
                <div class="score-value passed" id="passed-count">0</div>
                <div class="score-label">Pass</div>
            </div>
        </div>
    </div>

    <div class="card-counter" id="card-counter"></div>

    <div class="card-stack" id="card-stack">
        <!-- Cards injected by JS -->
    </div>

    <div class="action-buttons">
        <button class="action-btn undo-btn" id="undo-btn" disabled aria-label="Undo last swipe" title="Undo (Ctrl+Z)"><svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="1 4 1 10 7 10"/><path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"/></svg></button>
        <button class="action-btn nope" onclick="swipeCard('left')" aria-label="Pass"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg></button>
        <button class="action-btn bookmark" onclick="swipeCard('up')" aria-label="Save"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"/></svg></button>
        <button class="action-btn like" onclick="swipeCard('right')" aria-label="Like"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"/></svg></button>
    </div>
</div>

<div class="empty-state" id="empty-state" style="display: none;">
    <span class="empty-icon">&#x2728;</span>
    <h3>You're all caught up</h3>
    <p>You've reviewed everything available.<br>Check back later for new discoveries.</p>
    <a href="/" class="back-link">Browse All Tools</a>
</div>
{% endblock %}

{% block extra_scripts %}
<script>
let items = {{ items | tojson | safe }};
let currentIndex = 0;
let liked = 0, bookmarked = 0, passed = 0;
let bookmarks = JSON.parse(localStorage.getItem('vibecheck-bookmarks') || '[]');

// Drag state
// Undo state
let swipeHistory = [];
const undoBtn = document.getElementById('undo-btn');

let isDragging = false;
let startX = 0, startY = 0, currentX = 0, currentY = 0;
let currentCard = null;
let dragDirection = null; // 'horizontal' | 'vertical' | null

// Velocity tracking for fling detection
let lastMoveX = 0, lastMoveY = 0, lastMoveTime = 0;
let velocityX = 0, velocityY = 0;

const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

// Responsive thresholds scale with viewport
const THRESHOLD_X = Math.max(60, Math.min(80, window.innerWidth * 0.2));
const THRESHOLD_Y = Math.max(45, Math.min(60, window.innerHeight * 0.08));
const DIRECTION_LOCK_PX = 10;
const FLING_VELOCITY = 500; // px/s - swipes faster than this always commit

function updateCounter() {
    const remaining = items.length - currentIndex;
    document.getElementById('card-counter').textContent =
        remaining > 0 ? `${remaining} remaining` : '';
}

function createCard(item, index) {
    const card = document.createElement('div');
    card.className = 'swipe-card';
    card.style.zIndex = items.length - index;
    card.dataset.index = index;
    card.dataset.slug = item.slug;
    card.dataset.type = item.type;

    const typeBadge = item.type === 'article' ? 'article' : '';
    const typeLabel = item.type === 'article' ? 'Article' : 'Tool';
    const title = item.name || item.title || 'Untitled';
    const desc = item.description || item.summary || 'No description available';

    card.innerHTML = `
        <!-- Swipe feedback overlays -->
        <div class="swipe-overlay pass"><svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg></div>
        <div class="swipe-overlay like"><svg width="48" height="48" viewBox="0 0 24 24" fill="currentColor"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"/></svg></div>
        <div class="swipe-overlay save"><svg width="48" height="48" viewBox="0 0 24 24" fill="currentColor"><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"/></svg></div>

        <!-- Scrollable content zone -->
        <div class="card-content">
            <span class="card-type-badge ${typeBadge}">${typeLabel}</span>
            <h2 class="card-title">
                <a href="${item.url || '/tools/' + item.slug}" target="_blank">${title}</a>
            </h2>
            <p class="card-description">${desc}</p>
            <div class="card-tags">
                ${(item.categories || item.tags || []).slice(0, 4).map(t => `<span class="tag">${t}</span>`).join('')}
            </div>
            <div class="card-meta">
                ${item.github_stars ? `<span>\u2b50 ${item.github_stars.toLocaleString()}</span>` : ''}
                ${item.upvotes ? `<span>\ud83d\udc4d ${item.upvotes}</span>` : ''}
                ${item.community_slug ? `<span>\ud83d\udccd ${item.community_slug}</span>` : ''}
            </div>
        </div>

        <!-- Swipe handle zone -->
        <div class="swipe-handle">
            <span class="handle-instruction">Swipe to rate</span>
            <div class="grab-indicator"></div>
            <div class="direction-hints">
                <div class="direction-hint pass" data-dir="left">
                    <span class="icon">\u2190</span>
                    <span class="label">Pass</span>
                </div>
                <div class="direction-hint save" data-dir="up">
                    <span class="icon">\u2191</span>
                    <span class="label">Save</span>
                </div>
                <div class="direction-hint like" data-dir="right">
                    <span class="icon">\u2192</span>
                    <span class="label">Like</span>
                </div>
            </div>
        </div>
    `;

    // Attach drag events ONLY to the swipe handle
    const handle = card.querySelector('.swipe-handle');
    handle.addEventListener('mousedown', startDrag);
    handle.addEventListener('touchstart', startDrag, { passive: true });

    return card;
}

function renderCards() {
    const stack = document.getElementById('card-stack');
    stack.innerHTML = '';

    for (let i = Math.min(currentIndex + 2, items.length - 1); i >= currentIndex; i--) {
        if (items[i]) {
            const card = createCard(items[i], i);
            const offset = i - currentIndex;
            if (offset > 0) {
                // Deeper stacking: more scale, translate, opacity, and brightness changes
                card.style.transform = `scale(${1 - offset * 0.05}) translateY(${offset * 10}px)`;
                card.style.opacity = 1 - offset * 0.2;
                card.style.filter = `brightness(${1 - offset * 0.08})`;
            }
            stack.appendChild(card);

            // Entrance animation for top card after first swipe
            if (offset === 0 && currentIndex > 0) {
                card.classList.add('entering');
                card.offsetHeight; // force reflow
                card.style.transition = 'transform 0.4s cubic-bezier(0, 0, 0.2, 1), opacity 0.3s cubic-bezier(0, 0, 0.2, 1)';
                card.classList.remove('entering');
                // Restore base transition after entrance completes
                setTimeout(() => { card.style.transition = ''; }, 450);
            }
        }
    }

    updateCounter();

    if (currentIndex >= items.length) {
        document.querySelector('.discover-container').style.display = 'none';
        document.getElementById('empty-state').style.display = 'block';
    }
}

function startDrag(e) {
    if (currentIndex >= items.length) return;

    currentCard = e.currentTarget.closest('.swipe-card');
    if (!currentCard) return;

    isDragging = true;
    dragDirection = null;
    currentCard.classList.add('dragging');

    const touch = e.touches ? e.touches[0] : e;
    startX = touch.clientX;
    startY = touch.clientY;
    lastMoveX = startX;
    lastMoveY = startY;
    lastMoveTime = Date.now();
    currentX = 0;
    currentY = 0;
    velocityX = 0;
    velocityY = 0;

    document.addEventListener('mousemove', drag);
    document.addEventListener('touchmove', drag, { passive: false });
    document.addEventListener('mouseup', endDrag);
    document.addEventListener('touchend', endDrag);
}

function drag(e) {
    if (!isDragging || !currentCard) return;

    const touch = e.touches ? e.touches[0] : e;
    const deltaX = touch.clientX - startX;
    const deltaY = touch.clientY - startY;

    // Track velocity (smoothed)
    const now = Date.now();
    const dt = now - lastMoveTime;
    if (dt > 0) {
        const vx = (touch.clientX - lastMoveX) / dt * 1000;
        const vy = (touch.clientY - lastMoveY) / dt * 1000;
        // Smooth with previous velocity
        velocityX = velocityX * 0.4 + vx * 0.6;
        velocityY = velocityY * 0.4 + vy * 0.6;
        lastMoveX = touch.clientX;
        lastMoveY = touch.clientY;
        lastMoveTime = now;
    }

    // Lock direction after initial movement
    if (!dragDirection && (Math.abs(deltaX) > DIRECTION_LOCK_PX || Math.abs(deltaY) > DIRECTION_LOCK_PX)) {
        if (deltaY < -DIRECTION_LOCK_PX && Math.abs(deltaY) > Math.abs(deltaX)) {
            dragDirection = 'vertical';
        } else {
            dragDirection = 'horizontal';
        }
    }

    // Apply movement based on locked direction
    if (dragDirection === 'horizontal') {
        currentX = deltaX;
        currentY = 0;
        e.preventDefault();
    } else if (dragDirection === 'vertical' && deltaY < 0) {
        currentX = 0;
        currentY = Math.max(deltaY, -150);
        e.preventDefault();
    } else {
        return; // Allow default (e.g. page scroll)
    }

    // Transform card with rotation proportional to horizontal drag
    const rotate = currentX * 0.05;
    currentCard.style.transform = `translate(${currentX}px, ${currentY}px) rotate(${rotate}deg)`;

    updateFeedback();
}

function updateFeedback() {
    if (!currentCard) return;

    // Reset states
    currentCard.classList.remove('drag-left', 'drag-right', 'drag-up');
    currentCard.querySelectorAll('.direction-hint').forEach(h => h.classList.remove('active'));
    currentCard.querySelectorAll('.swipe-overlay').forEach(o => o.style.opacity = 0);

    const absX = Math.abs(currentX);
    const absY = Math.abs(currentY);

    if (currentY < -30 && absY > absX) {
        // Swiping up (save)
        currentCard.classList.add('drag-up');
        currentCard.querySelector('.direction-hint.save').classList.add('active');
        currentCard.querySelector('.swipe-overlay.save').style.opacity = Math.min(absY / THRESHOLD_Y, 1) * 0.7;

        if (currentY < -THRESHOLD_Y && !currentCard.hapticFired) {
            if (navigator.vibrate) navigator.vibrate(10);
            currentCard.hapticFired = true;
        }
    } else if (currentX > 30) {
        // Swiping right (like)
        currentCard.classList.add('drag-right');
        currentCard.querySelector('.direction-hint.like').classList.add('active');
        currentCard.querySelector('.swipe-overlay.like').style.opacity = Math.min(absX / THRESHOLD_X, 1) * 0.7;

        if (currentX > THRESHOLD_X && !currentCard.hapticFired) {
            if (navigator.vibrate) navigator.vibrate(10);
            currentCard.hapticFired = true;
        }
    } else if (currentX < -30) {
        // Swiping left (pass)
        currentCard.classList.add('drag-left');
        currentCard.querySelector('.direction-hint.pass').classList.add('active');
        currentCard.querySelector('.swipe-overlay.pass').style.opacity = Math.min(absX / THRESHOLD_X, 1) * 0.7;

        if (currentX < -THRESHOLD_X && !currentCard.hapticFired) {
            if (navigator.vibrate) navigator.vibrate(10);
            currentCard.hapticFired = true;
        }
    } else {
        currentCard.hapticFired = false;
    }
}

function endDrag() {
    if (!isDragging || !currentCard) return;

    document.removeEventListener('mousemove', drag);
    document.removeEventListener('touchmove', drag);
    document.removeEventListener('mouseup', endDrag);
    document.removeEventListener('touchend', endDrag);

    isDragging = false;
    currentCard.classList.remove('dragging', 'drag-left', 'drag-right', 'drag-up');

    // Velocity-based fling: fast swipes commit even below position threshold
    const isFlingRight = velocityX > FLING_VELOCITY;
    const isFlingLeft = velocityX < -FLING_VELOCITY;
    const isFlingUp = velocityY < -FLING_VELOCITY;

    // Determine action
    if ((currentY < -THRESHOLD_Y || isFlingUp) && Math.abs(currentY) > Math.abs(currentX)) {
        completeSwipe('up');
    } else if (currentX > THRESHOLD_X || isFlingRight) {
        completeSwipe('right');
    } else if (currentX < -THRESHOLD_X || isFlingLeft) {
        completeSwipe('left');
    } else {
        // Snap back with spring animation (CSS handles the overshoot curve)
        currentCard.style.transform = '';
        currentCard.querySelectorAll('.swipe-overlay').forEach(o => o.style.opacity = 0);
        currentCard.querySelectorAll('.direction-hint').forEach(h => h.classList.remove('active'));
    }

    currentCard = null;
    currentX = currentY = 0;
    dragDirection = null;
}

function swipeCard(direction) {
    const stack = document.getElementById('card-stack');
    const topCard = stack.querySelector('.swipe-card:last-child');
    if (!topCard) return;

    currentCard = topCard;
    velocityX = 0;
    velocityY = 0;

    // Skip wind-up animation for reduced motion users
    if (prefersReducedMotion) {
        completeSwipe(direction);
        return;
    }

    // Button wind-up: brief scale-down before fly-off
    const windUp = direction === 'left' ? 'scale(0.96) rotate(-3deg)'
                 : direction === 'right' ? 'scale(0.96) rotate(3deg)'
                 : 'scale(0.96) translateY(6px)';
    currentCard.style.transition = 'transform 0.08s ease-in';
    currentCard.style.transform = windUp;

    setTimeout(() => {
        currentCard.style.transition = '';
        completeSwipe(direction);
    }, 80);
}

function completeSwipe(direction) {
    if (!currentCard) return;

    const slug = currentCard.dataset.slug;
    const type = currentCard.dataset.type;

    // Save to undo history BEFORE removing (keep only last 1)
    swipeHistory = [{
        cardHTML: currentCard.outerHTML,
        direction: direction,
        slug: slug,
        type: type,
        index: currentIndex
    }];
    if (undoBtn) undoBtn.disabled = false;

    // Velocity-adaptive exit speed: fast flings fly off quicker
    const vel = Math.abs(velocityX || velocityY);
    const speed = prefersReducedMotion ? 0.01 : (vel > 800 ? 0.2 : vel > 400 ? 0.28 : 0.35);
    currentCard.style.transition = `transform ${speed}s ease-in, opacity ${speed}s ease-in`;

    currentCard.style.transform = '';  // Clear inline drag transform so CSS class takes effect
    currentCard.classList.add(`swiped-${direction}`);

    if (direction === 'right') {
        liked++;
        document.getElementById('liked-count').textContent = liked;
        voteItem(type, slug, 'upvote');
    } else if (direction === 'left') {
        passed++;
        document.getElementById('passed-count').textContent = passed;
        voteItem(type, slug, 'downvote');
    } else if (direction === 'up') {
        bookmarked++;
        document.getElementById('bookmarked-count').textContent = bookmarked;
        bookmarkItem(type, slug);
    }

    const delay = Math.max(speed * 1000, 180);
    setTimeout(() => {
        currentIndex++;
        renderCards();
    }, delay);
}

function voteItem(type, slug, action) {
    const endpoint = type === 'article'
        ? `/api/v1/articles/${slug}/${action}`
        : `/api/v1/tools/${slug}/${action}`;

    fetch(endpoint, { method: 'POST' }).catch(err => {
        console.error(err);
        if (typeof showToast === 'function') showToast('Vote failed to save. Please try again.');
    });
}

function bookmarkItem(type, slug) {
    const key = `${type}:${slug}`;
    if (!bookmarks.includes(key)) {
        bookmarks.push(key);
        localStorage.setItem('vibecheck-bookmarks', JSON.stringify(bookmarks));
    }
    voteItem(type, slug, 'upvote');
}

function setMode(mode) {
    window.location.href = `/discover?mode=${mode}`;
}

// === UNDO ===
function undoSwipe() {
    if (swipeHistory.length === 0) return;
    const last = swipeHistory.pop();
    if (undoBtn) undoBtn.disabled = swipeHistory.length === 0;

    // Decrement the appropriate score counter
    if (last.direction === 'right') {
        liked = Math.max(0, liked - 1);
        document.getElementById('liked-count').textContent = liked;
    } else if (last.direction === 'left') {
        passed = Math.max(0, passed - 1);
        document.getElementById('passed-count').textContent = passed;
    } else if (last.direction === 'up') {
        bookmarked = Math.max(0, bookmarked - 1);
        document.getElementById('bookmarked-count').textContent = bookmarked;
        // Remove from bookmarks localStorage if it was just added
        const key = `${last.type}:${last.slug}`;
        const idx = bookmarks.indexOf(key);
        if (idx !== -1) {
            bookmarks.splice(idx, 1);
            localStorage.setItem('vibecheck-bookmarks', JSON.stringify(bookmarks));
        }
    }

    // Step back the index and re-render (the item is still in the items array)
    currentIndex = last.index;
    renderCards();

    // Fire reverse API call to undo the vote
    if (last.direction === 'right') {
        voteItem(last.type, last.slug, 'downvote'); // reverse upvote
    } else if (last.direction === 'left') {
        voteItem(last.type, last.slug, 'upvote'); // reverse downvote
    }
    // For 'up' (bookmark+upvote), the bookmark was already removed above;
    // reverse the upvote too
    if (last.direction === 'up') {
        voteItem(last.type, last.slug, 'downvote');
    }
}

if (undoBtn) {
    undoBtn.addEventListener('click', undoSwipe);
}

// Keyboard shortcuts
document.addEventListener('keydown', (e) => {
    if ((e.key === 'z' && (e.ctrlKey || e.metaKey)) || e.key === 'u') {
        e.preventDefault();
        undoSwipe();
    }
    if (e.key === 'ArrowLeft') swipeCard('left');
    if (e.key === 'ArrowRight') swipeCard('right');
    if (e.key === 'ArrowUp') swipeCard('up');
});

renderCards();
</script>
{% endblock %}
